"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const pug_1 = __importDefault(require("pug"));
const fs_extra_1 = require("fs-extra");
const update_notifier_1 = __importDefault(require("update-notifier"));
const execa_1 = __importDefault(require("execa"));
const package_json_1 = require("../package.json");
const util_1 = require("./util");
update_notifier_1.default({
    pkg: {
        name: package_json_1.name,
        version: package_json_1.version
    },
    updateCheckInterval: 0,
    shouldNotifyInNpmScript: true
}).notify();
class default_1 {
    constructor() {
        this.config = {
            tsConfigPath: "./tsconfig.json",
            useFullDescription: false,
            useFullSnippet: false,
            failFastOnErrors: false
        };
        this.generateSnippet = pug_1.default.compileFile(path_1.default.join(__dirname, "template/snippet-summary.pug"));
        this.generateDescription = pug_1.default.compileFile(path_1.default.join(__dirname, "template/description-summary.pug"));
    }
    init(context) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.assign(this.config, context.config);
            const { useFullDescription, useFullSnippet } = this.config;
            if (useFullSnippet) {
                this.generateSnippet = pug_1.default.compileFile(path_1.default.join(__dirname, "template/snippet-full.pug"));
            }
            if (useFullDescription) {
                this.generateDescription = pug_1.default.compileFile(path_1.default.join(__dirname, "template/description-full.pug"));
            }
            const parsedData = yield this.getDependencies(context.logger);
            this.parsedComponentMap = parsedData.components.reduce((previous, current) => {
                const { file: key } = current;
                const existing = previous[key] || [];
                previous[key] = [...existing, current];
                return previous;
            }, {});
        });
    }
    process(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.parsedComponentMap) {
                return Promise.resolve({});
            }
            const rawComponents = this.parsedComponentMap[context.path] || [];
            const components = yield Promise.all(this.processComponents(rawComponents));
            const snippet = this.generateSnippet({ components });
            const description = this.generateDescription({ components });
            const lang = "markup" /* Markup */;
            return { description, snippet, lang };
        });
    }
    supports(x) {
        const filePath = x.path;
        return path_1.default.extname(filePath) === ".ts" &&
            filePath.lastIndexOf(".d.ts") === -1 &&
            filePath.lastIndexOf("spec.ts") === -1;
    }
    processComponents(rawComponents) {
        return rawComponents.map((rawComponent) => __awaiter(this, void 0, void 0, function* () {
            const { file, name, description, rawdescription: rawDescription, selector, inputsClass, propertiesClass, extends: _extends, implements: _implements, inputs: rawInputs, template, templateUrl } = rawComponent;
            let hasChildren = false;
            if (template && template.length > 0) {
                hasChildren = util_1.ngContentExists(template);
            }
            else if (templateUrl && templateUrl.length > 0 && templateUrl[0].length > 0) {
                const fileContent = yield fs_extra_1.readFile(path_1.default.join(path_1.default.dirname(file), templateUrl[0]));
                hasChildren = util_1.ngContentExists(fileContent.toString());
            }
            const selectors = [];
            const inputs = [];
            if (rawInputs) {
                rawInputs.forEach(input => {
                    const externalName = input.includes(":") ? input.split(":")[1].trim() : input.trim();
                    const internalName = input.includes(":") ? input.split(":")[0].trim() : input.trim();
                    let optional = true;
                    let type;
                    let defaultValue;
                    let desc = "";
                    const matchingProperty = propertiesClass.find(p => p.name === internalName);
                    if (matchingProperty) {
                        ({
                            type,
                            optional,
                            defaultValue,
                            description: desc
                        } = matchingProperty);
                    }
                    inputs.push({
                        name: externalName,
                        type,
                        optional,
                        defaultValue,
                        description: desc
                    });
                });
            }
            if (inputsClass) {
                inputsClass.forEach(i => inputs.push(i));
            }
            if (selector) {
                selector.replace(/\n/g, "")
                    .split(",")
                    .map(s => util_1.parseSelector(s.trim()))
                    .forEach(s => {
                    if (s) {
                        selectors.push(s);
                    }
                });
            }
            return {
                name,
                selectors,
                description,
                rawDescription,
                inputs,
                _extends,
                _implements,
                hasChildren
            };
        }));
    }
    getDependencies(logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const [pkgName] = package_json_1.name.split("/").slice(-1);
            const outputDirPath = path_1.default.join(os_1.default.tmpdir(), ".zeplin", pkgName);
            const tsConfigPath = path_1.default.resolve(this.config.tsConfigPath || "");
            try {
                const { stdout } = yield execa_1.default.command(`compodoc -p ${tsConfigPath} -e json -d ${outputDirPath}`, {
                    preferLocal: true,
                    localDir: __dirname
                });
                logger.debug(`compodoc output: ${stdout}`);
                const outputPath = path_1.default.join(outputDirPath, "documentation.json");
                const file = yield fs_extra_1.readFile(outputPath, "utf8");
                return JSON.parse(file);
            }
            catch (err) {
                logger.debug(`Error while running compodoc: ${err}`);
                if (this.config.failFastOnErrors) {
                    throw new Error("Error while generating component documentation");
                }
                return { components: [] };
            }
        });
    }
}
exports.default = default_1;
//# sourceMappingURL=index.js.map